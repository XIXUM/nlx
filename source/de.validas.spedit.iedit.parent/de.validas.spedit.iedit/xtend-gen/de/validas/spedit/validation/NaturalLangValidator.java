/**
 * generated by Xtext 2.16.0
 */
package de.validas.spedit.validation;

import com.google.inject.Inject;
import de.validas.nlx.dictionary.IDictionaryAccess;
import de.validas.nlx.dictionary.type.ITypeInfo;
import de.validas.nlx.dictionary.util.LogUtils;
import de.validas.spedit.constants.NaturalLangConstants;
import de.validas.spedit.naturalLang.Elements;
import de.validas.spedit.naturalLang.NaturalLangPackage;
import de.validas.spedit.naturalLang.Sentence;
import de.validas.spedit.naturalLang.SubSentence;
import de.validas.spedit.naturalLang.Word;
import de.validas.spedit.validation.AbstractNaturalLangValidator;
import javax.annotation.Generated;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.builder.debug.IBuildLogger;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
@Generated("org.eclipse.xtend.core.compiler.XtendGenerator")
public class NaturalLangValidator extends AbstractNaturalLangValidator {
  @Inject
  private IDictionaryAccess dictAcc;
  
  @Inject
  protected IBuildLogger buildLogger;
  
  protected LogUtils logUtil = new LogUtils(this.buildLogger);
  
  private boolean val_CAPITALIZE_PREF_ON = true;
  
  private boolean val_DICT_PREF_ON = true;
  
  @Check
  public void checkWordIsInDict(final Elements element) {
    if (this.val_DICT_PREF_ON) {
      if ((element instanceof Word)) {
        boolean _isConnected = this.dictAcc.isConnected();
        boolean _not = (!_isConnected);
        if (_not) {
          return;
        }
        EList<String> _word = ((Word)element).getWord();
        for (final String fragment : _word) {
          if (((fragment != null) && fragment.matches(NaturalLangConstants._MATCH_PATTERN))) {
            ITypeInfo result = this.dictAcc.findInDictionary(fragment);
            if ((result == null)) {
              this.info(String.format(NaturalLangConstants._TRAIN_TYPE, fragment), NaturalLangPackage.Literals.WORD__WORD, NaturalLangConstants._TRAIN_DICT, fragment);
            }
          }
        }
      }
    } else {
      this.logUtil.logAccess("Dict PREF", 1, "Dictionary Disabled");
    }
  }
  
  @Check
  public void checkSentenceStartsWithUpperCase(final SubSentence ssentence) {
    if (this.val_CAPITALIZE_PREF_ON) {
      EList<EObject> _elvis = null;
      EList<EObject> _elements = ssentence.getElements();
      if (((EList<EObject>) ((Object) _elements)) != null) {
        _elvis = ((EList<EObject>) ((Object) _elements));
      } else {
        BasicEList<EObject> _basicEList = new BasicEList<EObject>();
        _elvis = _basicEList;
      }
      EList<EObject> elList = _elvis;
      boolean _isEmpty = elList.isEmpty();
      if (_isEmpty) {
        return;
      }
      EObject _eContainer = ssentence.eContainer();
      Sentence sentence = ((Sentence) _eContainer);
      boolean _equals = sentence.getSubsentence().get(0).equals(ssentence);
      boolean _not = (!_equals);
      if (_not) {
        return;
      }
      EObject _get = ssentence.getElements().get(0);
      EObject el0 = ((EObject) _get);
      if ((el0 instanceof Word)) {
        boolean _isUpperCase = Character.isUpperCase(((Word)el0).getWord().get(0).charAt(0));
        boolean _not_1 = (!_isUpperCase);
        if (_not_1) {
          this.warning(NaturalLangConstants._CAPITALIZE_NAME, NaturalLangPackage.Literals.SUB_SENTENCE__ELEMENTS, NaturalLangConstants._TYPO, ((String[])Conversions.unwrapArray(((Word)el0).getWord(), String.class)));
        }
      }
    } else {
      this.logUtil.logAccess("Validate", 1, "Typography Disabled");
    }
  }
}
