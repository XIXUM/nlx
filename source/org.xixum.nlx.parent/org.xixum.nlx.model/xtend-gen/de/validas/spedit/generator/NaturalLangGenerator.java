/**
 * generated by Xtext 2.16.0
 */
package de.validas.spedit.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;
import com.google.inject.Inject;
import de.validas.spedit.constants.NaturalLangConstants;
import de.validas.spedit.constants.NaturalLangMessages;
import de.validas.spedit.generator.ChapterNumber;
import de.validas.spedit.generator.Context;
import de.validas.spedit.generator.utils.NlxGeneratorUtil;
import de.validas.spedit.generator.utils.ReflectiveUtils;
import de.validas.spedit.naturalLang.BlockElement;
import de.validas.spedit.naturalLang.BracketSentence;
import de.validas.spedit.naturalLang.ChapterSentence;
import de.validas.spedit.naturalLang.EString;
import de.validas.spedit.naturalLang.Elements;
import de.validas.spedit.naturalLang.ExtBracketSentence;
import de.validas.spedit.naturalLang.FootNote;
import de.validas.spedit.naturalLang.FreeSentence;
import de.validas.spedit.naturalLang.IgnoredText;
import de.validas.spedit.naturalLang.ItWord;
import de.validas.spedit.naturalLang.LineSentence;
import de.validas.spedit.naturalLang.LineSentenceChain;
import de.validas.spedit.naturalLang.ListSentence;
import de.validas.spedit.naturalLang.MailAdress;
import de.validas.spedit.naturalLang.Model;
import de.validas.spedit.naturalLang.New_Line;
import de.validas.spedit.naturalLang.NoNElement;
import de.validas.spedit.naturalLang.ParagraphBlock;
import de.validas.spedit.naturalLang.Quote;
import de.validas.spedit.naturalLang.Sentence;
import de.validas.spedit.naturalLang.SentenceChain;
import de.validas.spedit.naturalLang.SentenceChainX;
import de.validas.spedit.naturalLang.SentenceX;
import de.validas.spedit.naturalLang.ShortCut;
import de.validas.spedit.naturalLang.SimpleUnit;
import de.validas.spedit.naturalLang.SubSentence;
import de.validas.spedit.naturalLang.Symbols;
import de.validas.spedit.naturalLang.Table;
import de.validas.spedit.naturalLang.TableColumnSeparator;
import de.validas.spedit.naturalLang.TableLine;
import de.validas.spedit.naturalLang.TableRow;
import de.validas.spedit.naturalLang.Unit;
import de.validas.spedit.naturalLang.UrlAdress;
import de.validas.spedit.naturalLang.Word;
import de.validas.utils.data.lists.IAppendable;
import de.validas.utils.data.lists.XList;
import de.validas.utils.io.filesystem.File;
import de.validas.utils.io.filesystem.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Generated;
import metaModel.referenceProcess.ReferenceProcessFactory;
import metaModel.referenceProcess.RequiredDocument;
import metaModel.referenceProcess.Requirement;
import metaModel.suptertype.Named;
import org.apache.commons.lang.math.NumberUtils;
import org.eclipse.core.runtime.IPath;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.ILocationInFileProvider;
import org.eclipse.xtext.util.ITextRegion;
import org.eclipse.xtext.util.LineAndColumn;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.ObjectExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
@Generated("org.eclipse.xtend.core.compiler.XtendGenerator")
public class NaturalLangGenerator extends AbstractGenerator {
  @Inject
  protected ILocationInFileProvider locationInFileProvider;
  
  protected boolean content_table = true;
  
  public static final String _NL = "\n";
  
  private Context context;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    IPath absoluteLocation = NlxGeneratorUtil.findResourceInWS(resource);
    String _oSString = absoluteLocation.toOSString();
    Path documentPath = new Path(_oSString);
    IAppendable file = documentPath.getLastPathElement();
    if ((file instanceof File)) {
      ((File) file).setExtension(NaturalLangConstants.MODEL_EXTENSION);
    }
    URI fileURI = URI.createFileURI(documentPath.toFilePath().getAbsolutePath());
    Resource modelResource = this.createModelResource(fileURI);
    metaModel.referenceProcess.Process process = this.generateRequirementModel(resource.getAllContents());
    if ((process != null)) {
      modelResource.getContents().add(process);
    }
    this.createLinksRecursive(process.getRequirements());
    this.removeLinkReferences(process);
    this.saveModelResource(modelResource);
  }
  
  protected void createLinksRecursive(final EList<Requirement> requirements) {
    HashMap<String, List<Requirement>> referenceMap = CollectionLiterals.<String, List<Requirement>>newHashMap();
    this.recursiveRequirementMapper(requirements, referenceMap);
    this.recursiveRequirementConnector(null, requirements, referenceMap);
  }
  
  protected void removeLinkReferences(final metaModel.referenceProcess.Process process) {
    XList<Class<?>> classTypes = new XList<Class<?>>();
    classTypes.add(RequiredDocument.class);
    EList<EObject> allNodes = ReflectiveUtils.getAllChildren(process, classTypes, Boolean.valueOf(true));
    for (final EObject node : allNodes) {
      boolean _startsWith = ((Named) node).getName().startsWith(NaturalLangMessages.DESC_UNRESOLVED);
      boolean _not = (!_startsWith);
      if (_not) {
        EcoreUtil.delete(node, false);
      }
    }
  }
  
  protected void recursiveRequirementConnector(final Requirement parent, final EList<Requirement> reqList, final HashMap<String, List<Requirement>> map) {
    for (final Requirement req : reqList) {
      if ((!(req instanceof RequiredDocument))) {
        boolean _not = (!((req.getSubRequirements() == null) || req.getSubRequirements().isEmpty()));
        if (_not) {
          this.recursiveRequirementConnector(req, req.getSubRequirements(), map);
        }
      } else {
        if ((map.containsKey(req.getID()) && (parent != null))) {
          List<Requirement> _get = map.get(req.getID());
          final Function1<Requirement, Requirement> _function = (Requirement r) -> {
            String _description = r.getDescription();
            boolean _equals = false;
            if (_description!=null) {
              _equals=_description.equals(NaturalLangConstants._FOOTNOTE);
            }
            if (_equals) {
              LineAndColumn _positionInfo = this.getPositionInfo(r.getComment());
              int _line = 0;
              if (_positionInfo!=null) {
                _line=_positionInfo.getLine();
              }
              int childLine = _line;
              LineAndColumn _positionInfo_1 = this.getPositionInfo(parent.getComment());
              int _line_1 = 0;
              if (_positionInfo_1!=null) {
                _line_1=_positionInfo_1.getLine();
              }
              int parentLine = _line_1;
              int _abs = Math.abs((childLine - parentLine));
              boolean _lessThan = (_abs < 100);
              if (_lessThan) {
                return r;
              }
            } else {
              return r;
            }
            return null;
          };
          List<Requirement> linkedReq = ListExtensions.<Requirement, Requirement>map(new ArrayList<Requirement>(_get), _function);
          if (linkedReq!=null) {
            linkedReq.removeAll(Collections.<Object>singleton(null));
          }
          if ((linkedReq != null)) {
            parent.getRequiredRequirements().addAll(linkedReq);
          }
        } else {
          req.setName(NaturalLangMessages.DESC_UNRESOLVED);
        }
      }
    }
  }
  
  public LineAndColumn getPositionInfo(final String string) {
    Object _xblockexpression = null;
    {
      if ((string == null)) {
        return null;
      }
      boolean _isEmpty = string.isEmpty();
      if (_isEmpty) {
        return null;
      }
      final String regex = NaturalLangConstants._LINE_POSITION_REGEX;
      final Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
      final Matcher matcher = pattern.matcher(string);
      while (matcher.find()) {
        try {
          int line = Integer.parseInt(matcher.group("line"));
          int column = Integer.parseInt(matcher.group("column"));
          if (((line != 0) && (column != 0))) {
            return LineAndColumn.from(line, column);
          }
        } catch (final Throwable _t) {
          if (_t instanceof IllegalArgumentException) {
            return null;
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
      _xblockexpression = null;
    }
    return ((LineAndColumn)_xblockexpression);
  }
  
  protected void recursiveRequirementMapper(final EList<Requirement> reqList, final HashMap<String, List<Requirement>> map) {
    for (final Requirement req : reqList) {
      if (((!(req instanceof RequiredDocument)) && (req.getID() != null))) {
        String ID = req.getID();
        boolean _containsKey = map.containsKey(ID);
        if (_containsKey) {
          map.get(ID).add(req);
        } else {
          map.put(ID, CollectionLiterals.<Requirement>newArrayList(req));
        }
        boolean _not = (!((req.getSubRequirements() == null) || req.getSubRequirements().isEmpty()));
        if (_not) {
          this.recursiveRequirementMapper(req.getSubRequirements(), map);
        }
      }
    }
  }
  
  public void saveModelResource(final Resource modelResource) {
    try {
      HashMap<Object, Object> options = new HashMap<Object, Object>();
      options.put(XMLResource.OPTION_ENCODING, NaturalLangConstants.ENCODING);
      modelResource.save(options);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public Resource createModelResource(final URI fileURI) {
    ResourceSetImpl resourceSet = new ResourceSetImpl();
    return resourceSet.createResource(fileURI);
  }
  
  public metaModel.referenceProcess.Process generateRequirementModel(final TreeIterator<EObject> iterator) {
    metaModel.referenceProcess.Process process = ReferenceProcessFactory.eINSTANCE.createProcess();
    Context _context = new Context();
    this.context = _context;
    Requirement requirementObj = ReferenceProcessFactory.eINSTANCE.createRequirement();
    process.getRequirements().add(requirementObj);
    requirementObj.setName(NaturalLangConstants._INTRODUCTION);
    requirementObj.setID("0");
    requirementObj.setDescription(NaturalLangConstants._INTRO_DESC);
    EObject _root = this.getRoot(iterator);
    Model model = ((Model) _root);
    EList<EObject> _eContents = model.eContents();
    LinkedList<EObject> elements = new LinkedList<EObject>(_eContents);
    EObject last = null;
    PeekingIterator<EObject> pIterator = Iterators.<EObject>peekingIterator(elements.iterator());
    while (pIterator.hasNext()) {
      {
        EObject element = pIterator.next();
        EObject peek = null;
        boolean _hasNext = pIterator.hasNext();
        if (_hasNext) {
          peek = pIterator.peek();
        }
        boolean _matched = false;
        if (element instanceof ParagraphBlock) {
          _matched=true;
          Pair<String, Requirement> pair = this.paragraphToString(((ParagraphBlock)element), requirementObj);
          String text = pair.getKey();
          requirementObj = pair.getValue();
          this.buildLongDescrSentence(requirementObj, text);
        }
        if (!_matched) {
          if (element instanceof ChapterSentence) {
            _matched=true;
            if (((!this.isContentTable(peek, ((ChapterSentence)element), last)) || (!this.content_table))) {
              this.content_table = false;
              requirementObj = this.newRequirementObj(requirementObj, element);
              LineSentenceChain _headline = ((ChapterSentence)element).getHeadline();
              requirementObj.setName(this.lineSentenceChainToString(((SentenceChain) _headline), requirementObj));
            } else {
              StringConcatenation _builder = new StringConcatenation();
              String headline = _builder.toString();
              String _headline_1 = headline;
              EObject _chapterNumber = ((ChapterSentence)element).getChapterNumber();
              String _UnitToString = this.UnitToString(((Unit) _chapterNumber), requirementObj, false);
              headline = (_headline_1 + _UnitToString);
              String _headline_2 = headline;
              headline = (_headline_2 + " ");
              String _headline_3 = headline;
              LineSentenceChain _headline_4 = ((ChapterSentence)element).getHeadline();
              String _lineSentenceChainToString = this.lineSentenceChainToString(((SentenceChain) _headline_4), requirementObj);
              headline = (_headline_3 + _lineSentenceChainToString);
              String _headline_5 = headline;
              headline = (_headline_5 + NaturalLangGenerator._NL);
              this.buildLongDescrSentence(requirementObj, headline.toString());
            }
          }
        }
        if (!_matched) {
          if (element instanceof Table) {
            _matched=true;
            String text = this.TableToString(((Table)element), requirementObj);
            this.buildLongDescrSentence(requirementObj, text);
          }
        }
        last = element;
      }
    }
    return process;
  }
  
  public boolean isContentTable(final EObject peek, final ChapterSentence el, final EObject last) {
    boolean _xblockexpression = false;
    {
      boolean lastT = false;
      if ((last instanceof ChapterSentence)) {
        lastT = true;
      }
      ArrayList<EObject> elms = CollectionLiterals.<EObject>newArrayList();
      LineSentenceChain _headline = el.getHeadline();
      EList<EObject> _sentences = ((SentenceChain) _headline).getSentences();
      for (final EObject sents : _sentences) {
        EList<EObject> _subsentence = ((Sentence) sents).getSubsentence();
        for (final EObject subs : _subsentence) {
          elms.addAll(((SubSentence) subs).getElements());
        }
      }
      int _size = elms.size();
      boolean _greaterThan = (_size > 2);
      if (_greaterThan) {
        int _size_1 = elms.size();
        int _minus = (_size_1 - 2);
        EObject _get = elms.get(_minus);
        if ((_get instanceof IgnoredText)) {
          this.content_table = true;
          return true;
        }
      }
      if (((peek instanceof ChapterSentence) && lastT)) {
        return true;
      }
      _xblockexpression = false;
    }
    return _xblockexpression;
  }
  
  public Requirement newRequirementObj(final Requirement origRequirement, final EObject element) {
    Requirement requirementObj = ReferenceProcessFactory.eINSTANCE.createRequirement();
    EObject process = EcoreUtil.getRootContainer(origRequirement);
    requirementObj.setComment(this.getPosition(element));
    Named parent = null;
    if ((process instanceof metaModel.referenceProcess.Process)) {
      String chapter_num = "";
      boolean _matched = false;
      if (element instanceof ChapterSentence) {
        _matched=true;
        EObject _chapterNumber = ((ChapterSentence)element).getChapterNumber();
        chapter_num = IterableExtensions.join(((Unit) _chapterNumber).getValue());
        requirementObj.setID(chapter_num);
        Context _context = new Context();
        this.context = _context;
        parent = this.findParentChapter(((Named)process), requirementObj.getID());
        requirementObj.setDescription(NaturalLangConstants._SUB_CHAPTER);
      }
      if (!_matched) {
        if (element instanceof ListSentence) {
          _matched=true;
          chapter_num = ((ListSentence)element).getListpoint();
          String parentID = origRequirement.getID();
          if ((parentID == null)) {
            return origRequirement;
          }
          String num = null;
          Pattern pattern = Pattern.compile(NaturalLangConstants._REGEX_PATTERN);
          Matcher matcher = pattern.matcher(chapter_num);
          boolean _find = matcher.find();
          if (_find) {
            num = matcher.group(0);
            String _parentID = parentID;
            parentID = (_parentID + ".");
          } else {
            if ((this.context != null)) {
              num = NlxGeneratorUtil.getNumeric(chapter_num);
              if ((num != null)) {
                this.context.setLeading((NlxGeneratorUtil.StrToNum(num)).intValue());
              } else {
                this.context.incTrailing();
              }
            }
            String _parentID_1 = parentID;
            parentID = (_parentID_1 + NaturalLangConstants._DASH);
            num = this.context.generate();
          }
          String _parentID_2 = parentID;
          parentID = (_parentID_2 + num);
          requirementObj.setID(parentID);
          requirementObj.setDescription(NaturalLangConstants._SUB_REQUIREMENT);
          parent = origRequirement;
        }
      }
      if (!_matched) {
        if (element instanceof FootNote) {
          _matched=true;
          StringConcatenation _builder = new StringConcatenation();
          String _number = ((FootNote)element).getNumber();
          _builder.append(_number);
          requirementObj.setID(_builder.toString());
          requirementObj.setDescription(NaturalLangConstants._FOOTNOTE);
          parent = origRequirement;
        }
      }
      if (!_matched) {
        {
          requirementObj.setID(chapter_num);
          requirementObj.setDescription(NaturalLangConstants._SUB_CHAPTER);
          Context _context = new Context();
          this.context = _context;
          parent = origRequirement;
        }
      }
      if ((parent instanceof Requirement)) {
        ((Requirement)parent).getSubRequirements().add(requirementObj);
      } else {
        ((metaModel.referenceProcess.Process)process).getRequirements().add(requirementObj);
        requirementObj.setDescription(NaturalLangConstants._MAIN_CHAPTER);
      }
      return requirementObj;
    } else {
      return origRequirement;
    }
  }
  
  public String TableToString(final Table table, final Requirement requirement) {
    StringConcatenation _builder = new StringConcatenation();
    String sb = _builder.toString();
    List<Integer> columns = Collections.<Integer>unmodifiableList(CollectionLiterals.<Integer>newArrayList());
    EList<EObject> _lines = table.getLines();
    for (final EObject elm : _lines) {
      {
        if ((elm instanceof TableLine)) {
          columns = this.configureTable(((TableLine)elm).getContent());
          String _sb = sb;
          String _content = ((TableLine)elm).getContent();
          sb = (_sb + _content);
        } else {
          if ((elm instanceof TableRow)) {
            Pair<String, List<Integer>> result = this.TableRowToString(((TableRow)elm), requirement, columns);
            String _sb_1 = sb;
            String _key = result.getKey();
            sb = (_sb_1 + _key);
            columns = result.getValue();
          }
        }
        String _sb_2 = sb;
        sb = (_sb_2 + NaturalLangGenerator._NL);
      }
    }
    return sb.toString();
  }
  
  public List<Integer> configureTable(final String headline) {
    ArrayList<Integer> _xblockexpression = null;
    {
      final char plus = '+';
      final char minus = '-';
      ArrayList<Integer> columns = CollectionLiterals.<Integer>newArrayList();
      int column = 0;
      int len = 0;
      boolean firstborder = true;
      char[] _charArray = headline.toCharArray();
      for (final char elm : _charArray) {
        switch (elm) {
          case plus:
            if (firstborder) {
              firstborder = false;
            } else {
              columns.add(Integer.valueOf(len));
              column++;
              len = 0;
            }
            break;
          case minus:
            len++;
            break;
        }
      }
      _xblockexpression = columns;
    }
    return _xblockexpression;
  }
  
  public Pair<String, List<Integer>> TableRowToString(final TableRow row, final Requirement requirement, final List<Integer> columns) {
    List<Integer> intColumns = columns;
    StringConcatenation _builder = new StringConcatenation();
    String sb = _builder.toString();
    int column = 0;
    boolean firstborder = true;
    EObject last = null;
    int index = 0;
    EList<EObject> _content = row.getContent();
    for (final EObject elm : _content) {
      {
        if ((elm instanceof TableColumnSeparator)) {
          if (firstborder) {
            firstborder = false;
          } else {
            column++;
          }
          if (((last instanceof TableColumnSeparator) || (last instanceof TableLine))) {
            String _sb = sb;
            String _createCellContent = this.createCellContent("", intColumns, (column - 1));
            sb = (_sb + _createCellContent);
          }
          String _sb_1 = sb;
          String _char = ((TableColumnSeparator)elm).getChar();
          sb = (_sb_1 + _char);
        } else {
          if ((elm instanceof TableLine)) {
            List<Integer> blankLine = this.configureTable(((TableLine)elm).getContent());
            if (((last instanceof TableColumnSeparator) || (last instanceof TableLine))) {
              String _sb_2 = sb;
              String _createCellContent_1 = this.createCellContent("", intColumns, column);
              sb = (_sb_2 + _createCellContent_1);
            }
            intColumns = this.replaceColumns(row.getContent(), intColumns, blankLine, index);
            int _column = column;
            int _size = blankLine.size();
            column = (_column + _size);
            String _sb_3 = sb;
            String _content_1 = ((TableLine)elm).getContent();
            sb = (_sb_3 + _content_1);
          } else {
            if ((elm instanceof SentenceChain)) {
              String content = this.createCellContent(this.lineSentenceChainToString(((SentenceChain)elm), requirement), intColumns, column);
              String _sb_4 = sb;
              sb = (_sb_4 + content);
            }
          }
        }
        last = elm;
        index++;
      }
    }
    String _string = sb.toString();
    return new Pair<String, List<Integer>>(_string, intColumns);
  }
  
  public List<Integer> replaceColumns(final EList<EObject> row, final List<Integer> columns, final List<Integer> columnsIM, final int index) {
    List<Integer> _xblockexpression = null;
    {
      int last = row.size();
      int _size = columns.size();
      int colMax = (_size - 1);
      for (int i = index; (i < row.size()); i++) {
        {
          EObject token = row.get(i);
          if ((token instanceof TableColumnSeparator)) {
            last--;
          }
        }
      }
      List<Integer> result = columns.subList(0, Math.min(index, colMax));
      Iterables.<Integer>addAll(result, columnsIM);
      int _size_1 = row.size();
      boolean _lessThan = (last < _size_1);
      if (_lessThan) {
        List<Integer> _subList = columns.subList(Math.min(last, colMax), Math.min(row.size(), colMax));
        Iterables.<Integer>addAll(result, _subList);
      }
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  public String createCellContent(final String content, final List<Integer> columns, final int column) {
    String _xblockexpression = null;
    {
      int _size = columns.size();
      int _minus = (_size - 1);
      Integer _get = columns.get(Math.min(column, _minus));
      int length = ((_get).intValue() - 1);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(" ");
      _builder.append("%-");
      _builder.append(length, " ");
      _builder.append(".");
      _builder.append(length, " ");
      _builder.append("s");
      _xblockexpression = String.format(_builder.toString(), content);
    }
    return _xblockexpression;
  }
  
  public String lineSentenceChainToString(final SentenceChain chain, final Requirement requirement) {
    int i = 0;
    StringConcatenation _builder = new StringConcatenation();
    String sb = _builder.toString();
    EList<EObject> _sentences = chain.getSentences();
    for (final EObject token : _sentences) {
      if ((token instanceof LineSentence)) {
        String _sb = sb;
        String _sentenceToString = this.sentenceToString(((Sentence) token), requirement, 0, 0);
        sb = (_sb + _sentenceToString);
        int _size = chain.getSeparators().size();
        boolean _greaterThan = (_size > i);
        if (_greaterThan) {
          String _sb_1 = sb;
          String _get = chain.getSeparators().get(i);
          sb = (_sb_1 + _get);
        }
      }
    }
    if (((chain.getEndpoint() != null) && (!chain.getEndpoint().isEmpty()))) {
      String _sb_2 = sb;
      String _endpoint = chain.getEndpoint();
      sb = (_sb_2 + _endpoint);
    }
    return sb.toString();
  }
  
  protected Pair<String, Requirement> paragraphToString(final ParagraphBlock block, final Requirement requirement) {
    StringConcatenation _builder = new StringConcatenation();
    String sb = _builder.toString();
    EList<BlockElement> _block = block.getBlock();
    for (final BlockElement elm : _block) {
      boolean _matched = false;
      if (elm instanceof SentenceChain) {
        _matched=true;
        String _sb = sb;
        String _sentenceChainToString = this.sentenceChainToString(((SentenceChain)elm), requirement, 0);
        sb = (_sb + _sentenceChainToString);
      }
      if (!_matched) {
        if (elm instanceof ListSentence) {
          _matched=true;
          Pair<String, Requirement> pair = this.listSentenceToString(((ListSentence)elm), requirement);
          pair.getValue().getRequiredByRequirements().add(requirement);
          requirement.getRequiredRequirements().add(pair.getValue());
          String _sb = sb;
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append(NaturalLangMessages._LIST_REPLACEMENT_MSS);
          _builder_1.append(" ");
          String _iD = pair.getValue().getID();
          _builder_1.append(_iD);
          _builder_1.append(")");
          _builder_1.append(NaturalLangGenerator._NL);
          sb = (_sb + _builder_1);
        }
      }
      if (!_matched) {
        if (elm instanceof FootNote) {
          _matched=true;
          Pair<String, Requirement> pair = this.footNoteToString(((FootNote)elm), requirement);
          pair.getValue().getRequiredByRequirements().add(requirement);
          requirement.getRequiredRequirements().add(pair.getValue());
          String _sb = sb;
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append(NaturalLangMessages._FOOT_NOTE_MSS);
          _builder_1.append(" ");
          String _iD = pair.getValue().getID();
          _builder_1.append(_iD);
          _builder_1.append(")");
          _builder_1.append(NaturalLangGenerator._NL);
          sb = (_sb + _builder_1);
        }
      }
      if (!_matched) {
        if (elm instanceof IgnoredText) {
          _matched=true;
        }
      }
    }
    String _pEnd = block.getPEnd();
    boolean _tripleNotEquals = (_pEnd != null);
    if (_tripleNotEquals) {
      String _sb = sb;
      String _pEnd_1 = block.getPEnd();
      sb = (_sb + _pEnd_1);
    }
    return new Pair<String, Requirement>(sb, requirement);
  }
  
  public Pair<String, Requirement> footNoteToString(final FootNote note, final Requirement requirement) {
    Requirement internalReq = this.newRequirementObj(requirement, note);
    boolean _notEquals = (!Objects.equal(internalReq, requirement));
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("[Footnote] ");
      String _sentenceChainToString = this.sentenceChainToString(note.getSentenceChain(), requirement, NaturalLangConstants.NAME_MIN_LEN);
      _builder.append(_sentenceChainToString);
      internalReq.setName(_builder.toString());
    }
    StringConcatenation _builder_1 = new StringConcatenation();
    String _sentenceChainToString_1 = this.sentenceChainToString(note.getSentenceChain(), requirement, 0);
    _builder_1.append(_sentenceChainToString_1);
    String str = _builder_1.toString();
    this.buildLongDescrSentence(internalReq, str);
    return new Pair<String, Requirement>(str, internalReq);
  }
  
  protected Pair<String, Requirement> listSentenceToString(final ListSentence sentence, final Requirement requirement) {
    Requirement internalReq = this.newRequirementObj(requirement, sentence);
    boolean _notEquals = (!Objects.equal(internalReq, requirement));
    if (_notEquals) {
      SentenceChainX _sentenceChain = sentence.getSentenceChain();
      internalReq.setName(this.sentenceChainToString(((SentenceChain) _sentenceChain), null, NaturalLangConstants.NAME_MIN_LEN));
    }
    StringConcatenation _builder = new StringConcatenation();
    SentenceChainX _sentenceChain_1 = sentence.getSentenceChain();
    String _sentenceChainToString = this.sentenceChainToString(((SentenceChain) _sentenceChain_1), internalReq, 0);
    _builder.append(_sentenceChainToString);
    String str = _builder.toString();
    this.buildLongDescrSentence(internalReq, str);
    return new Pair<String, Requirement>(str, internalReq);
  }
  
  protected String sentenceChainToString(final SentenceChain chain, final Requirement requirement, final int len) {
    String _xblockexpression = null;
    {
      if ((chain == null)) {
        return "";
      }
      _xblockexpression = this.sentencesToString(chain.getSentences(), chain.getSeparators(), chain.getEndpoint(), requirement, 0, len);
    }
    return _xblockexpression;
  }
  
  protected String sentencesToString(final EList<? extends EObject> chain, final EList<String> separators, final String endpoint, final Requirement requirement, final int start, final int len) {
    StringConcatenation _builder = new StringConcatenation();
    String sb = _builder.toString();
    int index = 0;
    int sStart = 0;
    if ((chain == null)) {
      return new String();
    }
    String lastSentence = "";
    for (final SentenceX sentence : ((EList<SentenceX>) chain)) {
      {
        if ((index > 0)) {
          if (((len > 0) && (sb.length() > len))) {
            return sb;
          } else {
            int _length = lastSentence.length();
            boolean _greaterThan = (_length > 0);
            if (_greaterThan) {
              String _sb = sb;
              String _get = separators.get((index - 1));
              sb = (_sb + _get);
            }
          }
          sStart = 0;
        } else {
          sStart = start;
        }
        lastSentence = this.sentenceToString(((Sentence) sentence), requirement, sStart, len);
        String _sb_1 = sb;
        sb = (_sb_1 + lastSentence);
        index++;
      }
    }
    if ((endpoint != null)) {
      String _sb = sb;
      sb = (_sb + endpoint);
    }
    return sb;
  }
  
  public EObject getRoot(final TreeIterator<EObject> iterator) {
    Object _xifexpression = null;
    boolean _hasNext = iterator.hasNext();
    if (_hasNext) {
      return EcoreUtil.getRootContainer(iterator.next());
    } else {
      _xifexpression = null;
    }
    return ((EObject)_xifexpression);
  }
  
  protected void buildLongDescrSentence(final Requirement requirementObj, final String text) {
    String _longDescription = requirementObj.getLongDescription();
    boolean _tripleEquals = (_longDescription == null);
    if (_tripleEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(text);
      requirementObj.setLongDescription(_builder.toString());
    } else {
      String _longDescription_1 = requirementObj.getLongDescription();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(text);
      String _plus = (_longDescription_1 + _builder_1);
      requirementObj.setLongDescription(_plus);
    }
  }
  
  protected Named findParentChapter(final Named parent, final String chapter_num) {
    de.validas.utils.data.lists.LinkedList<ChapterNumber> chapter = new de.validas.utils.data.lists.LinkedList<ChapterNumber>();
    chapter = this.createChapterNum(chapter_num);
    int chapterHierarchy = this.truncateZeros(chapter);
    if ((chapterHierarchy <= 1)) {
      return parent;
    }
    XList<Class<?>> diagramClasses = new XList<Class<?>>();
    diagramClasses.add(Named.class);
    EList<? extends EObject> allNodes = ReflectiveUtils.getAllChildrenRecursive(parent, diagramClasses);
    final de.validas.utils.data.lists.LinkedList<ChapterNumber> _converted_chapter = (de.validas.utils.data.lists.LinkedList<ChapterNumber>)chapter;
    int _length = ((Object[])Conversions.unwrapArray(_converted_chapter, Object.class)).length;
    int _minus = (_length - 1);
    de.validas.utils.data.lists.LinkedList<ChapterNumber> parentChapter = chapter.subList(0, _minus);
    final de.validas.utils.data.lists.LinkedList<ChapterNumber> _converted_parentChapter = (de.validas.utils.data.lists.LinkedList<ChapterNumber>)parentChapter;
    int _length_1 = ((Object[])Conversions.unwrapArray(_converted_parentChapter, Object.class)).length;
    boolean _greaterThan = (_length_1 > 1);
    if (_greaterThan) {
      parentChapter = parentChapter.subList(0, this.truncateZeros(parentChapter));
    }
    de.validas.utils.data.lists.LinkedList<ChapterNumber> found_Chapter = new de.validas.utils.data.lists.LinkedList<ChapterNumber>();
    for (final Named node : ((EList<Named>) allNodes)) {
      if (((node instanceof Requirement) && (!(node instanceof RequiredDocument)))) {
        found_Chapter = this.createChapterNum(node.getID());
        if ((this.compareContent(found_Chapter, parentChapter) && Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(NaturalLangConstants._SUB_CHAPTER, NaturalLangConstants._MAIN_CHAPTER, NaturalLangConstants._SUB_REQUIREMENT, NaturalLangConstants._INTRO_DESC)).contains(ObjectExtensions.<String>operator_elvis(node.getDescription(), "")))) {
          return node;
        }
      }
    }
    return parent;
  }
  
  protected boolean compareContent(final de.validas.utils.data.lists.LinkedList<? extends IAppendable> original, final de.validas.utils.data.lists.LinkedList<? extends IAppendable> comparator) {
    int _size = original.size();
    int _size_1 = comparator.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      return false;
    }
    boolean equal = true;
    for (int i = 0; (i < original.size()); i++) {
      if ((equal && ((ChapterNumber) original.get(i)).number.equals(((ChapterNumber) comparator.get(i)).number))) {
        equal = true;
      } else {
        return false;
      }
    }
    return equal;
  }
  
  protected int truncateZeros(final de.validas.utils.data.lists.LinkedList<ChapterNumber> chapter) {
    int i = ((Object[])Conversions.unwrapArray(chapter, Object.class)).length;
    for (; (i > 0); i--) {
      {
        ChapterNumber _get = chapter.get((i - 1));
        String number = ((ChapterNumber) _get).number;
        boolean _not = (!(NumberUtils.isNumber(number) && ((Integer.decode(number)).intValue() == 0)));
        if (_not) {
          return i;
        }
      }
    }
    return 0;
  }
  
  protected de.validas.utils.data.lists.LinkedList<ChapterNumber> createChapterNum(final String chapter_num) {
    de.validas.utils.data.lists.LinkedList<ChapterNumber> chapter = new de.validas.utils.data.lists.LinkedList<ChapterNumber>();
    if (((chapter_num == null) || chapter_num.isEmpty())) {
      return new de.validas.utils.data.lists.LinkedList<ChapterNumber>();
    }
    String[] tokens = chapter_num.split("\\.");
    for (final String token : tokens) {
      ChapterNumber _chapterNumber = new ChapterNumber(token);
      chapter.add(_chapterNumber);
    }
    int zeros = this.truncateZeros(chapter);
    if ((zeros > 0)) {
      return chapter.subList(0, zeros);
    } else {
      return chapter;
    }
  }
  
  protected String sentenceToString(final Sentence sentence, final Requirement requirement, final int start, final int len) {
    String _xblockexpression = null;
    {
      EList<EObject> subS = ((Sentence) sentence).getSubsentence();
      int intStart = start;
      if (((len > 0) && (subS.size() > 0))) {
        EObject _get = subS.get(0);
        return this.relSubSentenceToString(((SubSentence) _get), requirement, intStart, len);
      }
      int i = 0;
      StringConcatenation _builder = new StringConcatenation();
      {
        boolean _hasElements = false;
        for(final EObject rSentence : subS) {
          if (!_hasElements) {
            _hasElements = true;
          } else {
            _builder.appendImmediate(", ", "");
          }
          {
            int _plusPlus = i++;
            boolean _greaterThan = (_plusPlus > 0);
            if (_greaterThan) {
              String _relSubSentenceToString = this.relSubSentenceToString(((SubSentence) rSentence), requirement, 0, 0);
              _builder.append(_relSubSentenceToString);
            } else {
              String _relSubSentenceToString_1 = this.relSubSentenceToString(((SubSentence) rSentence), requirement, intStart, 0);
              _builder.append(_relSubSentenceToString_1);
            }
          }
        }
      }
      String str = _builder.toString();
      _xblockexpression = str;
    }
    return _xblockexpression;
  }
  
  protected String elementToString(final Elements element, final Requirement requirement, final int len) {
    boolean _matched = false;
    if (element instanceof Word) {
      _matched=true;
      return IterableExtensions.join(((Word)element).getWord(), "");
    }
    if (!_matched) {
      if (element instanceof Unit) {
        _matched=true;
      }
      if (!_matched) {
        if (element instanceof SimpleUnit) {
          _matched=true;
        }
      }
      if (_matched) {
        return this.UnitToString(element, requirement, true);
      }
    }
    if (!_matched) {
      if (element instanceof ShortCut) {
        _matched=true;
        EObject _shortcut = ((ShortCut)element).getShortcut();
        EString scEl = ((EString) _shortcut);
        String _elvis = null;
        String _shortcut_1 = scEl.getShortcut();
        if (_shortcut_1 != null) {
          _elvis = _shortcut_1;
        } else {
          String _join = IterableExtensions.join(scEl.getWord(), "");
          _elvis = _join;
        }
        return _elvis;
      }
    }
    if (!_matched) {
      if (element instanceof ItWord) {
        _matched=true;
        return IterableExtensions.join(((ItWord)element).getWord(), "");
      }
    }
    if (!_matched) {
      if (element instanceof Quote) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\"");
        String _quote = ((Quote)element).getQuote();
        _builder.append(_quote);
        _builder.append("\"");
        return _builder.toString();
      }
    }
    if (!_matched) {
      if (element instanceof ExtBracketSentence) {
        _matched=true;
      }
      if (!_matched) {
        if (element instanceof BracketSentence) {
          _matched=true;
        }
      }
      if (_matched) {
        if ((len > 0)) {
          return this.sentencesToString(((BracketSentence)element).getBrackedSentences(), ((BracketSentence)element).getSeparator(), null, requirement, 0, len);
        }
        return this.brackedSentenceToText(((BracketSentence)element), ((BracketSentence)element).getOpen().charAt(0), ((BracketSentence)element).getClose().charAt(0), requirement);
      }
    }
    if (!_matched) {
      if (element instanceof Symbols) {
        _matched=true;
        return ((Symbols)element).getSymbol();
      }
    }
    if (!_matched) {
      if (element instanceof UrlAdress) {
        _matched=true;
        String _protocol = ((UrlAdress)element).getProtocol();
        String _join = IterableExtensions.join(((UrlAdress)element).getUrl(), "");
        return (_protocol + _join);
      }
    }
    if (!_matched) {
      if (element instanceof MailAdress) {
        _matched=true;
        return IterableExtensions.join(((MailAdress)element).getEmail(), "");
      }
    }
    if (!_matched) {
      if (element instanceof IgnoredText) {
        _matched=true;
        return ((IgnoredText)element).getIgnored();
      }
    }
    if (!_matched) {
      if (element instanceof New_Line) {
        _matched=true;
        return element.getNl();
      }
    }
    return null;
  }
  
  public String UnitToString(final Elements unit, final Requirement requirement, final boolean addRequirement) {
    String _xblockexpression = null;
    {
      StringConcatenation _builder = new StringConcatenation();
      String result = _builder.toString();
      if ((unit instanceof Unit)) {
        EList<String> _value = ((Unit)unit).getValue();
        if ((_value instanceof EList)) {
          String _result = result;
          String _join = IterableExtensions.join(((Unit)unit).getValue(), " ");
          result = (_result + _join);
        }
        String _unit = ((Unit)unit).getUnit();
        boolean _tripleNotEquals = (_unit != null);
        if (_tripleNotEquals) {
          String _result_1 = result;
          String _unit_1 = ((Unit)unit).getUnit();
          result = (_result_1 + _unit_1);
        }
      } else {
        if ((unit instanceof SimpleUnit)) {
          EList<String> _value_1 = ((SimpleUnit)unit).getValue();
          if ((_value_1 instanceof EList)) {
            String _result_2 = result;
            String _join_1 = IterableExtensions.join(((SimpleUnit)unit).getValue(), " ");
            result = (_result_2 + _join_1);
          }
        }
      }
      if ((requirement == null)) {
        return result;
      }
      EList<Requirement> _subRequirements = requirement.getSubRequirements();
      for (final Requirement req : _subRequirements) {
        String _iD = req.getID();
        boolean _tripleEquals = (_iD == result);
        if (_tripleEquals) {
          return result;
        }
      }
      if (addRequirement) {
        this.addSubRequirement(result, requirement, unit);
      }
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  public Requirement addSubRequirement(final String id, final Requirement requirement, final EObject unit) {
    Requirement _xblockexpression = null;
    {
      RequiredDocument reqDocumentNode = ReferenceProcessFactory.eINSTANCE.createRequiredDocument();
      reqDocumentNode.setID(id);
      reqDocumentNode.setName(NaturalLangConstants._INTERNAL_REF_NODE);
      reqDocumentNode.setLongDescription(this.getPosition(unit));
      requirement.getSubRequirements().add(reqDocumentNode);
      _xblockexpression = requirement;
    }
    return _xblockexpression;
  }
  
  public String getPosition(final EObject elm) {
    String _xblockexpression = null;
    {
      ITextRegion loc = this.locationInFileProvider.getSignificantTextRegion(elm);
      ICompositeNode node = NodeModelUtils.getNode(elm);
      LineAndColumn linecol = NodeModelUtils.getLineAndColumn(node, loc.getOffset());
      URI uri = EcoreUtil.getURI(elm);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Position [Line: ");
      int _line = linecol.getLine();
      _builder.append(_line);
      _builder.append(" | Column: ");
      int _column = linecol.getColumn();
      _builder.append(_column);
      _builder.append("]");
      _builder.newLineIfNotEmpty();
      _builder.append("URI: ");
      _builder.append(uri);
      _xblockexpression = _builder.toString();
    }
    return _xblockexpression;
  }
  
  protected String subSentenceToString(final SubSentence ssentence, final Requirement requirement, final int start, final int len) {
    StringConcatenation _builder = new StringConcatenation();
    String sb = _builder.toString();
    int index = 0;
    int intStart = start;
    try {
      while (((!(ssentence.getElements().get(intStart) instanceof NoNElement)) && (intStart < (((Object[])Conversions.unwrapArray(ssentence.getElements(), Object.class)).length - 1)))) {
        int _intStart = intStart;
        intStart = (_intStart + 1);
      }
    } catch (final Throwable _t) {
      if (_t instanceof IndexOutOfBoundsException) {
        if ((intStart > 0)) {
          int _intStart = intStart;
          intStart = (_intStart - 1);
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    EList<EObject> _elements = ssentence.getElements();
    for (final EObject element : _elements) {
      {
        if (((len > 0) && (len <= sb.length()))) {
          return sb.toString();
        }
        if ((index > intStart)) {
          String _sb = sb;
          sb = (_sb + " ");
        }
        if ((index >= intStart)) {
          String _sb_1 = sb;
          String _elementToString = this.elementToString(((Elements) element), requirement, len);
          sb = (_sb_1 + _elementToString);
        }
        index++;
      }
    }
    return sb;
  }
  
  protected String relSubSentenceToString(final SubSentence ssentence, final Requirement requirement, final int start, final int len) {
    return this.subSentenceToString(ssentence, requirement, start, len);
  }
  
  protected String brackedSentenceToText(final BracketSentence bs, final char startingBr, final char endBr, final Requirement requirement) {
    String _xblockexpression = null;
    {
      String extractName = "";
      String firstEl = this.getElement(bs, 0);
      int start = 0;
      if (((firstEl != null) && ((firstEl.toLowerCase().equals(NaturalLangConstants._NOTE) || firstEl.toLowerCase().equals(NaturalLangConstants._EXAMPLE)) || firstEl.toLowerCase().equals(NaturalLangConstants._SOURCE)))) {
        extractName = firstEl;
        int _start = start;
        start = (_start + 1);
        String secondEl = this.getElement(bs, 1);
        try {
          Integer num = Integer.decode(secondEl);
          String _extractName = extractName;
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("-");
          _builder.append(num);
          extractName = (_extractName + _builder);
          int _start_1 = start;
          start = (_start_1 + 1);
        } catch (final Throwable _t) {
          if (_t instanceof NumberFormatException) {
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(startingBr);
      {
        if ((start > 0)) {
          CharSequence _extractBracket = this.extractBracket(bs, start, extractName, requirement);
          _builder_1.append(_extractBracket);
        } else {
          String _sentencesToString = this.sentencesToString(bs.getBrackedSentences(), bs.getSeparator(), null, requirement, 0, 0);
          _builder_1.append(_sentencesToString);
        }
      }
      _builder_1.append(endBr);
      String str = _builder_1.toString();
      _xblockexpression = str;
    }
    return _xblockexpression;
  }
  
  public String getElement(final EObject el, final int idx) {
    EList<Sentence> sentences = null;
    boolean _matched = false;
    if (el instanceof ExtBracketSentence) {
      _matched=true;
    }
    if (!_matched) {
      if (el instanceof BracketSentence) {
        _matched=true;
      }
    }
    if (_matched) {
      EList<FreeSentence> _brackedSentences = ((BracketSentence)el).getBrackedSentences();
      sentences = ((EList<Sentence>) ((Object) _brackedSentences));
    }
    if (!_matched) {
      if (el instanceof SentenceChain) {
        _matched=true;
        EList<EObject> _sentences = ((SentenceChain)el).getSentences();
        sentences = ((EList<Sentence>) ((Object) _sentences));
      }
    }
    int counter = 0;
    List<Sentence> _elvis = null;
    if (sentences != null) {
      _elvis = sentences;
    } else {
      _elvis = Collections.<Sentence>unmodifiableList(CollectionLiterals.<Sentence>newArrayList());
    }
    for (final Sentence sentence : _elvis) {
      List<EObject> _elvis_1 = null;
      EList<EObject> _subsentence = sentence.getSubsentence();
      if (_subsentence != null) {
        _elvis_1 = _subsentence;
      } else {
        _elvis_1 = Collections.<EObject>unmodifiableList(CollectionLiterals.<EObject>newArrayList());
      }
      for (final EObject subs : _elvis_1) {
        if ((subs instanceof SubSentence)) {
          List<EObject> _elvis_2 = null;
          EList<EObject> _elements = ((SubSentence)subs).getElements();
          if (_elements != null) {
            _elvis_2 = _elements;
          } else {
            _elvis_2 = Collections.<EObject>unmodifiableList(CollectionLiterals.<EObject>newArrayList());
          }
          for (final EObject elms : _elvis_2) {
            {
              if ((counter == idx)) {
                return this.elementToString(((Elements) elms), null, 0);
              }
              counter++;
            }
          }
        }
      }
    }
    return null;
  }
  
  public CharSequence extractBracket(final BracketSentence bs, final int start, final String extractName, final Requirement requirement) {
    CharSequence _xblockexpression = null;
    {
      Requirement internalReq = this.newRequirementObj(requirement, bs);
      EList<FreeSentence> sentences = bs.getBrackedSentences();
      EList<String> sep = bs.getSeparator();
      CharSequence _xifexpression = null;
      boolean _notEquals = (!Objects.equal(internalReq, requirement));
      if (_notEquals) {
        CharSequence _xblockexpression_1 = null;
        {
          String id = requirement.getID();
          StringConcatenation _builder = new StringConcatenation();
          _builder.append(id);
          {
            boolean _contains = id.contains(NaturalLangConstants._DASH);
            if (_contains) {
              _builder.append(".");
            } else {
              _builder.append("-");
            }
          }
          _builder.append(extractName);
          internalReq.setID(_builder.toString());
          internalReq.setName(this.sentencesToString(sentences, sep, null, null, start, NaturalLangConstants.NAME_MIN_LEN));
          internalReq.setDescription(extractName);
          internalReq.setLongDescription(this.sentencesToString(sentences, sep, null, internalReq, start, 0));
          requirement.getSubRequirements().add(internalReq);
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append(extractName);
          _builder_1.append(" ");
          _builder_1.append(NaturalLangMessages._NOTE_REPL_MSS);
          _builder_1.append(" ");
          String _iD = internalReq.getID();
          _builder_1.append(_iD);
          _xblockexpression_1 = _builder_1;
        }
        _xifexpression = _xblockexpression_1;
      } else {
        _xifexpression = this.sentencesToString(sentences, sep, null, internalReq, 0, 0);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
}
