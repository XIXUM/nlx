/*
 * generated by Xtext 2.16.0
 */
package org.xixum.nlx.generator

import com.google.common.collect.Iterators
import com.google.inject.Inject
import org.xixum.nlx.generator.utils.NlxGeneratorUtil
import org.xixum.nlx.generator.utils.ReflectiveUtils
import org.xixum.nlx.naturalLang.BlockElement
import org.xixum.nlx.naturalLang.BracketSentence
import org.xixum.nlx.naturalLang.ChapterSentence
import org.xixum.nlx.naturalLang.EString
import org.xixum.nlx.naturalLang.Elements
import org.xixum.nlx.naturalLang.ExtBracketSentence
import org.xixum.nlx.naturalLang.FootNote
import org.xixum.nlx.naturalLang.IgnoredText
import org.xixum.nlx.naturalLang.ItWord
import org.xixum.nlx.naturalLang.LineSentence
import org.xixum.nlx.naturalLang.ListSentence
import org.xixum.nlx.naturalLang.MailAdress
import org.xixum.nlx.naturalLang.Model
import org.xixum.nlx.naturalLang.New_Line
import org.xixum.nlx.naturalLang.NoNElement
import org.xixum.nlx.naturalLang.ParagraphBlock
import org.xixum.nlx.naturalLang.Quote
import org.xixum.nlx.naturalLang.Sentence
import org.xixum.nlx.naturalLang.SentenceChain
import org.xixum.nlx.naturalLang.SentenceX
import org.xixum.nlx.naturalLang.ShortCut
import org.xixum.nlx.naturalLang.SimpleUnit
import org.xixum.nlx.naturalLang.SubSentence
import org.xixum.nlx.naturalLang.Symbols
import org.xixum.nlx.naturalLang.Table
import org.xixum.nlx.naturalLang.TableColumnSeparator
import org.xixum.nlx.naturalLang.TableLine
import org.xixum.nlx.naturalLang.TableRow
import org.xixum.nlx.naturalLang.Unit
import org.xixum.nlx.naturalLang.UrlAdress
import org.xixum.nlx.naturalLang.Word
import org.xixum.utils.data.lists.IAppendable
import org.xixum.utils.data.lists.LinkedList
import org.xixum.utils.data.lists.XList
import org.xixum.utils.io.filesystem.File
import org.xixum.utils.io.filesystem.Path
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.regex.Matcher
import java.util.regex.Pattern
import metaModel.referenceProcess.Process
import metaModel.referenceProcess.ReferenceProcessFactory
import metaModel.referenceProcess.RequiredDocument
import metaModel.referenceProcess.Requirement
import metaModel.suptertype.Named
import org.apache.commons.lang.math.NumberUtils
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.TreeIterator
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.emf.ecore.xmi.XMLResource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.resource.ILocationInFileProvider
import org.eclipse.xtext.util.LineAndColumn

import static org.xixum.nlx.constants.NaturalLangConstants.*
import static org.xixum.nlx.constants.NaturalLangMessages.*
import static org.xixum.nlx.generator.utils.ReflectiveUtils.getAllChildrenRecursive

import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NaturalLangGenerator extends AbstractGenerator {

	@Inject
	protected ILocationInFileProvider locationInFileProvider;

	protected boolean content_table = true
	
	public static val _NL = "\n"

	/**
	 * 
	 */
	
	Context context
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var absoluteLocation = NlxGeneratorUtil.findResourceInWS(resource)
		var documentPath = new Path(absoluteLocation.toOSString)
		var file = documentPath.getLastPathElement()
		if (file instanceof File) {
			(file as File).extension = MODEL_EXTENSION
		}
		var URI fileURI = URI.createFileURI(documentPath.toFilePath.absolutePath)
		var modelResource = createModelResource(fileURI)
		var process = generateRequirementModel(resource.allContents)
		if (process !== null) {
			modelResource.getContents().add(process);
		}
		createLinksRecursive(process.requirements)
		removeLinkReferences(process)
		saveModelResource(modelResource)
	}

	/**
	 * 
	 */
	protected def createLinksRecursive(EList<Requirement> requirements) {
		var referenceMap = newHashMap();
		recursiveRequirementMapper(requirements, referenceMap)
		recursiveRequirementConnector(null, requirements, referenceMap)
	}

	/**
	 * 
	 */
	protected def removeLinkReferences(Process process) {
		var classTypes = new XList<Class<?>>();
		classTypes.add(RequiredDocument);
		var allNodes = ReflectiveUtils.getAllChildren(process, classTypes, true);
		for (EObject node : allNodes) {
			if (!(node as Named).name.startsWith(DESC_UNRESOLVED))
				EcoreUtil.delete(node, false); // keep unresolved Links
		}
	}

	/**
	 * 
	 */
	protected def void recursiveRequirementConnector(Requirement parent, EList<Requirement> reqList, HashMap<String, List<Requirement>> map) {
		for (Requirement req : reqList) {
			if (!(req instanceof RequiredDocument)) {
				if (!( req.subRequirements === null || req.subRequirements.isEmpty())) {
					recursiveRequirementConnector(req, req.subRequirements, map)
				}
			} else {
				if (map.containsKey(req.ID) && parent !== null) {
					var linkedReq = new ArrayList<Requirement>(map.get(req.ID)).map[r | if (r.description?.equals(_FOOTNOTE)){
						var childLine = getPositionInfo(r.comment)?.line
						var parentLine = getPositionInfo(parent.comment)?.line
						if (Math.abs(childLine-parentLine)<100)
							return r
					} else return r 
					return null  ]
					linkedReq?.removeAll(Collections.singleton(null))
					if (linkedReq!==null)
						parent.requiredRequirements.addAll(linkedReq)
				// EcoreUtil.delete(req, true);
				} else {
					req.name = DESC_UNRESOLVED
				}
			}
		}
	}
	
	def LineAndColumn getPositionInfo(String string) {
		if (string === null)
			return null
		if (string.empty) 
				return null	
		val regex = _LINE_POSITION_REGEX
		val Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
        val Matcher matcher = pattern.matcher(string);
        while (matcher.find()) {
        	try {
            	var line = Integer.parseInt(matcher.group('line'))
            	var column = Integer.parseInt(matcher.group('column'))
            	if (line != 0 && column != 0)
            		return LineAndColumn.from(line, column) 		
            } catch (IllegalArgumentException e) {
            	return null
            }
        }
        null
	}

	/**
	 * 
	 */
	protected def void recursiveRequirementMapper(EList<Requirement> reqList, HashMap<String, List<Requirement>> map) {
		for (Requirement req : reqList) {
			if (!(req instanceof RequiredDocument) && req.ID !== null) {
				var ID = req.ID
				if (map.containsKey(ID))
					map.get(ID).add(req)
				else
					map.put(ID, newArrayList(req))
				if (!( req.subRequirements === null || req.subRequirements.isEmpty())) {
					recursiveRequirementMapper(req.subRequirements, map)
				}
			}
		}
	}

	/**
	 * 
	 */
	def saveModelResource(Resource modelResource) {
		// Save the contents of the resource to the file system.
		//
		var options = new HashMap<Object, Object>();
		options.put(XMLResource.OPTION_ENCODING, ENCODING);
		modelResource.save(options);
	}

	def Resource createModelResource(URI fileURI) {
		var resourceSet = new ResourceSetImpl();
		return resourceSet.createResource(fileURI);
	}

	/*
	 * 
	 */
	def Process generateRequirementModel(TreeIterator<EObject> iterator) {
		var process = ReferenceProcessFactory.eINSTANCE.createProcess();
		
		context = new Context()
		
		// requirementPointer. Pointing to the current working requirement-object:
		var requirementObj = ReferenceProcessFactory.eINSTANCE.createRequirement();
		process.getRequirements().add(requirementObj);
		requirementObj.name = _INTRODUCTION
		requirementObj.ID = "0"
		requirementObj.description = _INTRO_DESC
		var model = getRoot(iterator) as Model
		var elements = new java.util.LinkedList(model.eContents())
		var EObject last = null
		var pIterator = Iterators.peekingIterator(elements.iterator)
		
		while (pIterator.hasNext) {
			var EObject element = pIterator.next
			var EObject peek = null
			if (pIterator.hasNext) {
				peek = pIterator.peek
			}
			switch (element){
				ParagraphBlock: {
					var pair = paragraphToString(element, requirementObj);
					var text = pair.key
					requirementObj = pair.value
					buildLongDescrSentence(requirementObj, text)
				}
				ChapterSentence: {
					if (!isContentTable(peek, element, last) || !content_table) {
						content_table = false
						requirementObj = newRequirementObj(requirementObj, element)
						requirementObj.name = lineSentenceChainToString(element.headline as SentenceChain, requirementObj)
					} else {
						var headline = ''''''
						headline += UnitToString(element.chapterNumber as Unit, requirementObj, false)
						
						headline += ' '  
						headline += lineSentenceChainToString(element.headline as SentenceChain, requirementObj)
						headline += _NL
						buildLongDescrSentence(requirementObj, headline.toString())
					}
				}
				Table: {
					var String text = TableToString(element, requirementObj);
					buildLongDescrSentence(requirementObj, text)
				}
			}
			last = element
		}
		return process;
	}
	
	def isContentTable(EObject peek, ChapterSentence el, EObject last) {
		var lastT = false
		if (last instanceof ChapterSentence) 
			lastT = true
			
		var elms = newArrayList()
		for(sents: (el.headline as SentenceChain).sentences ){
			for (subs : (sents as Sentence).subsentence)
				elms.addAll((subs as SubSentence).elements)
		}
		if (elms.size>2){
			if (elms.get(elms.size-2) instanceof IgnoredText){
				content_table = true
				return true
			}
		}
		
		if (peek instanceof ChapterSentence && lastT)
			return true
	
		false
	}

	def Requirement newRequirementObj(Requirement origRequirement, EObject element) {
		var requirementObj = ReferenceProcessFactory.eINSTANCE.createRequirement();
		var process = EcoreUtil.getRootContainer(origRequirement)
		requirementObj.comment = getPosition(element)
		var Named parent
		if (process instanceof Process) {
			var chapter_num = ""
			switch element {
				ChapterSentence: {
					 chapter_num = (element.chapterNumber as Unit).value.join
					 requirementObj.ID = chapter_num;
					 context = new Context()	
					 parent = findParentChapter(process, requirementObj.ID)
					 requirementObj.description = _SUB_CHAPTER
				}
				ListSentence: {
					chapter_num = element.listpoint
					var parentID = origRequirement.ID
					if (parentID === null)
						return origRequirement
					var String num
					var pattern = Pattern.compile(_REGEX_PATTERN);  //TODO: opposite match (bullet points)
					var matcher = pattern.matcher(chapter_num);
					if (matcher.find()) {
						num = matcher.group(0)
						parentID += "."
					} else {
						if (context !== null){
							num = NlxGeneratorUtil.getNumeric(chapter_num)
							if (num !== null){
								context.setLeading(NlxGeneratorUtil.StrToNum(num))
							} else {
								context.incTrailing()
							}
						}
	
						parentID += _DASH
						num = context.generate
					}
					parentID += num
					requirementObj.ID = parentID
					requirementObj.description = _SUB_REQUIREMENT //"Sub Requirement"
					parent = origRequirement
				}
				FootNote: {
					requirementObj.ID = '''«element.number»'''
					requirementObj.description = _FOOTNOTE //"Footnote"
					parent = origRequirement
				}
				default:{
					requirementObj.ID = chapter_num;
					requirementObj.description = _SUB_CHAPTER //"Sub Chapter"
					context = new Context()
					parent = origRequirement
				}
			}
			
			if (parent instanceof Requirement) {
				parent.subRequirements.add(requirementObj)				
			} else {
				process.requirements.add(requirementObj)
				requirementObj.description = _MAIN_CHAPTER //"Main Chapter"
			}
			return requirementObj
		} else {
			return origRequirement
		}
	}

	def TableToString(Table table, Requirement requirement) {
		var sb = ''''''
		var List<Integer> columns = #[]
		for (EObject elm : table.lines) {
			if (elm instanceof TableLine) {
				columns = configureTable(elm.content)
				sb += elm.content
			} else if (elm instanceof TableRow) {
				var result = TableRowToString(elm, requirement, columns)
				sb += result.key
				columns = result.value
			}
			sb += _NL  //_NEW_LINE
		}
		return sb.toString
	}

	def List<Integer> configureTable(String headline) {
		val char plus = '+'
		val char minus = '-'
		var columns = newArrayList()
		var column = 0 // TODO: obsolete
		var len = 0
		var firstborder = true
		for (char elm : headline.toCharArray) {
			switch elm {
				case plus: {
					if (firstborder)
						firstborder = false
					else {
						columns.add(len)
						column++
						len = 0
					}
				}
				case minus: {
					len++
				// columns.set(column, len)
				}
			}
		}
		columns
	}

	def TableRowToString(TableRow row, Requirement requirement, List<Integer> columns) {
		var intColumns = columns
		var sb = ''''''
		var column = 0;
		var firstborder = true
		var EObject last = null
		var index = 0
		for (EObject elm : row.content) {   //TODO: 11.10.21 Table generation Buggy
			if (elm instanceof TableColumnSeparator) {
				if (firstborder)
					firstborder = false
				else
					column++
				if (last instanceof TableColumnSeparator || last instanceof TableLine) {
					sb += createCellContent('', intColumns, column - 1)
				}
				sb += elm.char
			} else if (elm instanceof TableLine) {
				var blankLine = configureTable(elm.content)
				if (last instanceof TableColumnSeparator || last instanceof TableLine) {
					sb += createCellContent('', intColumns, column)
				}
				intColumns = replaceColumns(row.content, intColumns, blankLine, index)
				column += blankLine.size
				sb += elm.content
			} else if (elm instanceof SentenceChain) {
				var String content = createCellContent(lineSentenceChainToString(elm, requirement), intColumns, column)  //TODO: wrong column calculation
				sb += content
			}
			last = elm
			index++
		}
		return new Pair<String, List<Integer>>(sb.toString, intColumns)
	}

	def replaceColumns(EList<EObject> row, List<Integer> columns, List<Integer> columnsIM, int index) {
		var last = row.size()
		var colMax = columns.size()-1
		for (var i = index; i < row.size(); i++) {
			var token = row.get(i)
			if (token instanceof TableColumnSeparator)
				last--
		}
		var List<Integer> result = columns.subList(0, Math.min(index,colMax)) //TODO: 11.10.21: index out of bounds bug
		result += columnsIM
		if (last < row.size())
			result += columns.subList(Math.min(last,colMax), Math.min(row.size(),colMax))   //TODO: 11.10.21 fix index out of bounds
		result
	}

	def createCellContent(String content, List<Integer> columns, int column) {
		//TODO: 11.10.21 index out of bounds:
		
		var length = columns.get(Math.min(column,columns.size()-1)) - 1
		String.format(''' %-«length».«length»s''', content);
	}

	def lineSentenceChainToString(SentenceChain chain, Requirement requirement) {
		var int i = 0
		var sb = ''''''
		for (EObject token : chain.sentences)
			if (token instanceof LineSentence) {
				sb += sentenceToString(token as Sentence, requirement,0, 0)
				if (chain.separators.size() > i)
					sb += chain.separators.get(i)
			}
		if (chain.endpoint !== null && !chain.endpoint.empty) {
			sb += chain.endpoint
		} 
 
		return sb.toString
	}

	protected def paragraphToString(ParagraphBlock block, Requirement requirement) {
		
		var sb = ''''''
		
		for (BlockElement elm : block.block)
			switch (elm){
				SentenceChain:{
					sb += sentenceChainToString(elm, requirement, 0)
				}
				ListSentence: {
					var pair = listSentenceToString(elm, requirement)
					pair.value.requiredByRequirements.add(requirement)
					requirement.requiredRequirements.add(pair.value)
					
					sb += '''«_LIST_REPLACEMENT_MSS» «pair.value.ID»)«_NL»'''
					//internalReq = pair.value
				}
				FootNote: {
					var pair = footNoteToString(elm, requirement)
					pair.value.requiredByRequirements.add(requirement)
					requirement.requiredRequirements.add(pair.value)
					sb += '''«_FOOT_NOTE_MSS» «pair.value.ID»)«_NL»'''
				}
				IgnoredText:{
					//Ignore 
				}
			}
			
		if (block.PEnd !== null)
			sb += block.PEnd // weather paragraph gap with '.' at the end or not 
		return new Pair<String, Requirement>(sb, requirement)
	}
	
	def footNoteToString(FootNote note, Requirement requirement) {
		var internalReq = newRequirementObj(requirement, note)
		if (internalReq != requirement)
			internalReq.name = '''[Footnote] «sentenceChainToString(note.sentenceChain, requirement, NAME_MIN_LEN)»''' //TODO: strip new line
			
		var str ='''«sentenceChainToString(note.sentenceChain, requirement, 0)»'''
		buildLongDescrSentence(internalReq, str)
		return new Pair<String, Requirement>(str,internalReq)
	}

	protected def listSentenceToString(ListSentence sentence, Requirement requirement) {
		var internalReq = newRequirementObj(requirement, sentence)
		if (internalReq != requirement)
			internalReq.name = sentenceChainToString(sentence.sentenceChain as SentenceChain, null, NAME_MIN_LEN) //TODO: strip new line
			
		var str ='''«sentenceChainToString(sentence.sentenceChain as SentenceChain, internalReq, 0)»'''
		buildLongDescrSentence(internalReq, str)
		return new Pair<String, Requirement>(str,internalReq)
	}

	protected def sentenceChainToString(SentenceChain chain, Requirement requirement, int len){
		if (chain === null) return ""
		sentencesToString(chain.sentences, chain.separators, chain.endpoint, requirement, 0,  len)
	}

	protected def sentencesToString(EList<? extends EObject> chain, EList<String> separators, String endpoint, Requirement requirement, int start, int len) {
		var sb = ''''''
		var int index = 0
		var int sStart = 0
		if (chain === null) return new String
		var lastSentence = ""
		for (SentenceX sentence : chain as EList<SentenceX>) {  // odd type inferring Sentence->FreeSentence
			if (index > 0){
				if (len > 0 && sb.length> len)
					return sb
				else 
					if (lastSentence.length > 0)
						sb += separators.get(index - 1)
				sStart = 0
			} else {
				sStart = start
			}
			lastSentence = sentenceToString(sentence as Sentence, requirement, sStart, len)
			sb += lastSentence
			index++
		}
		if (endpoint !== null) {
			sb += endpoint
		}
		return sb
	}

	def getRoot(TreeIterator<EObject> iterator) {
		if (iterator.hasNext()) {
			return EcoreUtil.getRootContainer(iterator.next())
		} else
			null
	}

	/** 
	 * 
	 */
	protected def void buildLongDescrSentence(Requirement requirementObj, String text) {
		if (requirementObj.longDescription === null)
			requirementObj.longDescription = '''«text»'''
		else
			requirementObj.longDescription = requirementObj.longDescription + '''«text»'''
	}

	protected def Named findParentChapter(Named parent, String chapter_num) {
		var LinkedList<ChapterNumber> chapter = new LinkedList<ChapterNumber>();
		chapter = createChapterNum(chapter_num)
		var int chapterHierarchy = truncateZeros(chapter)
		if (chapterHierarchy <= 1) {
			return parent
		}
		var XList<Class<?>> diagramClasses = new XList<Class<?>>();
		diagramClasses.add(Named)
		var EList<? extends EObject> allNodes = (getAllChildrenRecursive(parent, diagramClasses))
		var LinkedList<ChapterNumber> parentChapter = chapter.subList(0, chapter.length - 1)
		if (parentChapter.length > 1)
			parentChapter = parentChapter.subList(0, truncateZeros(parentChapter))
		var LinkedList<ChapterNumber> found_Chapter = new LinkedList<ChapterNumber>();
		for (Named node : allNodes as EList<Named>) {
			if (node instanceof Requirement && ! (node instanceof RequiredDocument)) {
				found_Chapter = createChapterNum(node.ID)
				if (compareContent(found_Chapter, parentChapter) && ( #[_SUB_CHAPTER, _MAIN_CHAPTER, _SUB_REQUIREMENT, _INTRO_DESC].contains(node.description?:""))) {
					return node
				}
			}
		}
		return parent
	}

	protected def compareContent(LinkedList<? extends IAppendable> original, LinkedList<? extends IAppendable> comparator) {
		if (original.size != comparator.size) return false;
		var boolean equal = true;
		for (var int i = 0; i < original.size; i++) {
			// TODO: should be negated. positive if is obsolete, because 'equal' never turns into false
			if (equal && (original.get(i) as ChapterNumber).number.equals((comparator.get(i) as ChapterNumber).number))
				equal = true // nonsense, but xtend does not allow continue or break
			else
				return false
		}
		return equal
	}

	protected def int truncateZeros(LinkedList<ChapterNumber> chapter) {
		var int i = chapter.length
		for (; i > 0; i--) {
			var number = (chapter.get(i - 1) as ChapterNumber).number
			if (!(NumberUtils.isNumber(number) && Integer.decode(number) == 0)) return i; //TODO: 01.12.21 decoding numbers errorous: "1d"
		}
		return 0;
	}

	protected def LinkedList<ChapterNumber> createChapterNum(String chapter_num) {
		var LinkedList<ChapterNumber> chapter = new LinkedList<ChapterNumber>()
		if (chapter_num === null || chapter_num.empty) // Return Empty List
			return new LinkedList<ChapterNumber>()
		var String[] tokens = chapter_num.split('\\.')
		for (String token : tokens) {
			chapter.add(new ChapterNumber(token))
		}
		var zeros = truncateZeros(chapter)
		if (zeros > 0) { 
			return chapter.subList(0, zeros) 
		}else
			return chapter
	}

	protected def sentenceToString(Sentence sentence, Requirement requirement,int start, int len) {
		var subS = (sentence as Sentence).subsentence
		var intStart = start
		if (len > 0 && subS.size > 0)
			return relSubSentenceToString(subS.get(0) as SubSentence, requirement, intStart, len)
		var i = 0
		var str = '''«FOR rSentence : subS SEPARATOR(', ')
						»«IF i++ > 0
						»«relSubSentenceToString(rSentence as SubSentence, requirement, 0, 0)»«
						ELSE»«relSubSentenceToString(rSentence as SubSentence, requirement, intStart, 0)»«
						ENDIF»«
					ENDFOR»'''
//					IF sentence.endPoint !== null
//						»«sentence.endPoint»«
//					ENDIF»'''
		str
	}

	protected def String elementToString(Elements element, Requirement requirement, int len) {
		switch element {
			Word: {
				return element.word.join('')
			}
			Unit,
			SimpleUnit: {
				return UnitToString(element, requirement, true)
			}
			ShortCut:{
				var scEl = element.shortcut as EString
				return scEl.shortcut ?: scEl.word.join('')
			}
			ItWord:
				return element.word.join('')
			Quote:
				return '''"«element.quote»"'''
			ExtBracketSentence,
			BracketSentence: {
				if (len > 0)
					return sentencesToString(element.brackedSentences, element.separator, null, requirement, 0, len)
				return brackedSentenceToText(element, element.open.charAt(0), element.close.charAt(0), requirement)
			}
			Symbols:
				return element.symbol
			UrlAdress:
				return element.protocol + element.url.join('')
			MailAdress:
				return element.email.join('')
			IgnoredText:
				return element.ignored
			New_Line:
				return element.nl
		}
	}

	def String UnitToString(Elements unit, Requirement requirement, boolean addRequirement) {
		var result = ''''''
		if (unit instanceof Unit){
			if (unit.value instanceof EList) {
				result += unit.value.join(' ')	
			}
			if (unit.unit !== null)
				result += unit.unit
		} else if (unit instanceof SimpleUnit) {
			if (unit.value instanceof EList) {
				result += unit.value.join(' ')	
			}
		}
		 
		if (requirement === null)
			return result
		for (req : requirement.subRequirements) {
			if (req.ID === result)
				return result
		}
		if (addRequirement)
			addSubRequirement(result, requirement, unit)
		result
	}
	
	def addSubRequirement(String id, Requirement requirement, EObject unit){
		var RequiredDocument reqDocumentNode = ReferenceProcessFactory.eINSTANCE.createRequiredDocument();
		reqDocumentNode.ID = id
		reqDocumentNode.name = _INTERNAL_REF_NODE //"Internal Reference Node"
		reqDocumentNode.longDescription = getPosition(unit) 
		requirement.subRequirements.add(reqDocumentNode)
		requirement
	}
	
	def getPosition(EObject elm) {
		var loc = locationInFileProvider.getSignificantTextRegion(elm)
		var node = elm.node
		var linecol = node.getLineAndColumn(loc.offset)
		var uri =  EcoreUtil.getURI(elm)
		'''Position [Line: «linecol.line» | Column: «linecol.column»]
URI: «uri»'''.toString
	}

	protected def String subSentenceToString(SubSentence ssentence, Requirement requirement, int start, int len) {
		var sb = ''''''
		var int index = 0
		var intStart = start
		//var str ='''«FOR element : ssentence.elements SEPARATOR(' ')»«elementToString(element as Elements, requirement)»'''
		try {
			while (!(ssentence.elements.get(intStart) instanceof NoNElement) && intStart < ssentence.elements.length -1)
				intStart += 1
			
		} catch (IndexOutOfBoundsException e) {
			if (intStart > 0)
				intStart -= 1
		}
		for (element : ssentence.elements) {
			if (len>0 && len <= sb.length)
				return sb.toString
			if (index > intStart)
				sb +=' '
			if (index >= intStart) sb += elementToString(element as Elements, requirement, len) 
			index++
		}
		return sb
	}

	protected def String relSubSentenceToString(SubSentence ssentence, Requirement requirement,int start, int len) {
		return subSentenceToString(ssentence, requirement,start, len)
	}

	protected def String brackedSentenceToText(BracketSentence bs, char startingBr, char endBr, Requirement requirement) {
		var extractName = ""   
		var firstEl = getElement(bs, 0)
		var start = 0
		if (firstEl !== null && (firstEl.toLowerCase.equals(_NOTE) || firstEl.toLowerCase.equals(_EXAMPLE) || firstEl.toLowerCase.equals(_SOURCE))){
			extractName =  firstEl
			start += 1
			var secondEl = getElement(bs, 1)
			try {
				var num = Integer.decode(secondEl)
				extractName += '''-«num»'''
				start += 1	
			} 
			catch (NumberFormatException e) {
				
			}
		}
		
		var str = '''«startingBr»«
			IF start > 0»«
				extractBracket(bs, start, extractName, requirement)»«
			ELSE»«
				sentencesToString(bs.brackedSentences, bs.separator, null, requirement, 0, 0)»«
			ENDIF»«endBr»'''
		str
	}
	
	def getElement(EObject el, int idx) {
		var EList<Sentence> sentences
		switch (el){
			ExtBracketSentence,
			BracketSentence: {
				sentences = (el.brackedSentences as Object)  as EList<Sentence>
			}
			SentenceChain:{
				sentences = (el.sentences as Object) as EList<Sentence>
			}
		}
		var counter = 0
		for (sentence : sentences ?: #[]){
			
			for (EObject subs : sentence.subsentence ?: #[]){
				if (subs instanceof SubSentence){
					for (elms: subs.elements ?: #[]){
						if (counter == idx)
							return elementToString(elms as Elements, null, 0)
						counter++
					}
				}
			}
		}
	}
	
	def extractBracket(BracketSentence bs, int start, String extractName, Requirement requirement) {
		var internalReq = newRequirementObj(requirement, bs)
		var sentences = bs.brackedSentences
		var sep = bs.separator
		if (internalReq != requirement){
			var id = requirement.ID
			internalReq.ID = '''«id»«IF (id.contains(_DASH))».«ELSE»-«ENDIF»«extractName»'''
			internalReq.name = sentencesToString(sentences, sep, null, null, start, NAME_MIN_LEN)
			internalReq.description = extractName
			internalReq.longDescription = sentencesToString(sentences, sep, null, internalReq, start, 0)
			//addToParent(requirement, internalReq)
			requirement.subRequirements.add(internalReq)
			'''«extractName» «_NOTE_REPL_MSS» «internalReq.ID»'''
		} else 
			sentencesToString(sentences, sep, null, internalReq, 0, 0)
	}
	
//	def addToParent(Requirement requirement, Requirement requirementObj) {
//		var process = EcoreUtil.getRootContainer(requirement)
//		if (process instanceof Process){
//			var Named parent = findParentChapter(process, requirement.ID)
//			if (parent instanceof Requirement) {
//				parent.subRequirements.add(requirementObj)				
//			} else {
//				process.requirements.add(requirementObj)	
//			}
//		}
//	}
	
}